% ----------- Document settings -----------
\documentclass[nonacm, sigconf, balance=true]{acmart}
\include{core/paperSettings} % import custom general paper settings
\include{core/standardCommands} % import custom commands and packages
% -----------------------------------------
\begin{document}

    \clearpage
    \onecolumn

% ====================================================


    \section[Semiotiek: \textbf{Mens-Informatie}]{Semiotiek}
    Semiotiek is het zelfde als 'tekenleer'. Denk hierbij aan:
    \begin{itemize}
        \item letters (A-Z)
        \item Karakters (chinees alfabet)
        \item Woorden
        \item Morsetekens/braille
        \item verkeerdborden, pictogrammern
        \item gebaren
        \item voorwerpen (witte vlag, e.d)
    \end{itemize}

    Semiotiek houd zich bezeig met elke activiteit, handeling of preces waarbij tekens worden gebruitk.
    Een teken defineren we als: "Alles dat een booschap communiceert van de zender naar de ontvanger"

    \subsection{De semiotische ladder}

    \subsection{Fysieke tekens (Technische laag)}
    Dit houdt alles in van Klanken die je met je mond maakt tot gebaren, letters, Geuren e.d.
    Tekens kunnen op zichzelf al een betekenis hebben, maar kunnen ook met elkaar een betekenis hebben.
    Bijvoorbeeld: Het naam "Roderick" is een reeks van tekens (letters) die samen een betekenis hebben.
    Ofwel, de drager van de boodschap.

    \subsection{Het empirische niveau (Technische laag)}
    Dit niveau houd zich bezig met de waarneembare eigenschappen van tekens.
    Bijvoorbeeld: De letters in het woord "Roderick" hebben een bepaalde vorm, kleur, grootte e.d.
    Ook de klanken die je maakt als je het woord uitspreekt hebben bepaalde eigenschappen zoals toonhoogte, volume e.d.
    Dit niveau is vooral belangrijk voor de technische verwerking van tekens, zoals bij spraakherkenning of beeldherkenning.
    Ofwel, hoe de boodschap wordt overgebracht.

    \subsection{Syntax}
    Syntax is de studie van de regels die bepalen hoe tekens gecombineerd kunnen worden om grotere eenheden te vormen.
    Bijvoorbeeld: In het Nederlands is de volgorde van woorden in een zin belangrijk voor de betekenis.
    "De kat zit op de mat" heeft een andere betekenis dan "Op de mat zit de kat".
    Syntax is dus de structuur van tekens en hoe ze samenhangen.
    Ofwel, hoe de boodschap is opgebouwd.

    \subsection{Semantiek}
    Semantiek is de studie van de betekenis van tekens en hoe ze worden geïnterpreteerd.
    Bijvoorbeeld: Het woord "kat" verwijst naar een bepaald dier, maar in een andere context kan het ook een metafoor zijn voor iets anders.
    Semantiek gaat dus over de relatie tussen tekens en hun betekenis.
    Ofwel, wat de boodschap inhoudt.


    \textbf{Objectivisme}: Beteknis is vast en objectief.
    Woorden hebben een vaste betekenis die niet verandert.
    Denk aan woordenboeken die de betekenis van woorden definiëren.

    \textbf{Constructivisme}: Betekenis is subjectief en contextafhankelijk.
    Woorden kunnen verschillende betekenissen hebben afhankelijk van de context en de interpretatie van de ontvanger.
    Denk aan hoe straattaal of jargon verschillende betekenissen kunnen hebben in verschillende groepen.
    (bijv. ``cool'' kan zowel ``koud'' als ``gaaf'' betekenen)

    \tecxtbf{Pragmatisme}: Betekenis ontstaat in de interactie tussen zender en ontvanger.
    Woorden krijgen betekenis door het gebruik ervan in communicatie.
    Denk aan hoe de betekenis van een woord kan veranderen afhankelijk van hoe het wordt gebruikt in een gesprek.

    \textbf{Determinisme}: Betekenis wordt bepaald door externe factoren zoals cultuur, geschiedenis en sociale context.
    Woorden kunnen verschillende betekenissen hebben in verschillende culturen of tijdperken.
    Denk aan hoe bepaalde woorden in het verleden een andere betekenis hadden dan nu.
    (bijv. ``gay'' betekende vroeger ``vrolijk'' maar nu wordt het voornamelijk gebruikt om seksuele geaardheid aan te duiden)

    \subsection{Pragmatiek}
    Pragmatiek is de studie van hoe tekens worden gebruikt in communicatie en hoe de context de betekenis beïnvloedt.
    Bijvoorbeeld: Het woord "kat" kan verschillende betekenissen hebben afhankelijk van de situatie waarin het wordt gebruikt.
    Als iemand zegt "Ik heb een kat", kan dit betekenen dat ze een huisdier hebben, maar het kan ook een uitdrukking zijn van iets anders, afhankelijk van de context.
    Pragmatiek gaat dus over de praktische aspecten van communicatie en hoe tekens worden gebruikt in de echte wereld.
    Ofwel, de bedoeling achter de boodschap.

    \subsection{Samenvatting}
    De semiotische ladder bestaat uit vijf niveaus:
    \begin{itemize}
        \item Fysieke tekens (Technische laag): De drager van de boodschap
        \item Empirische niveau (Technische laag): Hoe de boodschap wordt overgebracht
        \item Syntax: Hoe de boodschap is opgebouwd
        \item Semantiek: Wat de boodschap inhoudt
        \item Pragmatiek: De bedoeling achter de boodschap
    \end{itemize}


    \section{Kennisbanken}
    Graafstructuren bestaan uit een verzameling van punten en knopen die met elkaar verbonden zijn door lijnen (ongerichte graaf) of pijlen (gerichte graaf).
    In een kennisbank worden concepten voorgesteld als knopen en de relaties tussen deze concepten als lijnen of pijlen.
    Kennisbanken kunnen worden gebruikt om informatie te organiseren, te structureren en te analyseren.

    \subsection{relationele database}
    Een relationele database is een type database dat gegevens opslaat in tabellen die met elkaar verbonden zijn door relaties.
    Elke tabel bestaat uit rijen en kolommen, waarbij elke rij een record vertegenwoordigt en elke kolom een attribuut van dat record (denk aan een spreadsheet).
    Relaties tussen tabellen worden gemaakt door middel van primaire en vreemde sleutels.
    Relationele databases worden vaak gebruikt voor het opslaan van gestructureerde gegevens en het uitvoeren van complexe queries.

    \subsection{SQL}
    SQL (Structured Query Language) is een programmeertaal die wordt gebruikt voor het beheren en manipuleren van relationele databases.
    Met SQL kunnen gebruikers gegevens opvragen, invoegen, bijwerken en verwijderen uit de database.
    SQL biedt ook mogelijkheden voor het definiëren van de structuur van de database, zoals het maken van tabellen en het definiëren van relaties tussen tabellen.
    SQL is een gestandaardeerde taal en wordt ondersteund door de meeste relationele databasebeheersystemen.

    \subsection{NoSQL}
    NoSQL (Not Only SQL) is een type database dat niet gebaseerd is op het relationele model.
    In plaats daarvan gebruiken NoSQL-databases verschillende gegevensmodellen, zoals documenten, grafieken, kolomgeoriënteerde opslag en sleutel-waardeparen.
    NoSQL-databases zijn ontworpen om schaalbaarheid, flexibiliteit en prestaties te bieden voor het opslaan van grote hoeveelheden ongestructureerde of semi-gestructureerde gegevens.
    NoSQL-databases worden vaak gebruikt in big data-toepassingen en real-time webapplicaties.

    \subsection{Faceted Search}
    Faceted search is een zoektechniek die gebruikers in staat stelt om zoekresultaten te verfijnen door middel van verschillende categorieën.
    In een faceted search-systeem worden zoekresultaten georganiseerd op basis van verschillende categorieën, zoals prijs, merk, kleur, grootte, enzovoort.
    Gebruikers kunnen vervolgens filters toepassen op deze categorieën om de zoekresultaten te beperken tot diegene die aan hun specifieke criteria voldoen.
    Faceted search wordt vaak gebruikt in e-commerce websites en digitale bibliotheken om gebruikers te helpen snel de gewenste informatie te vinden.

    \subsection{Term Frequency enInverse Document Frequency ($TF\times IDF$)}
    Term Frequency (TF) is een maatstaf voor hoe vaak een term voorkomt in een document.
    Het wordt berekend door het aantal keren dat een term voorkomt in een document te delen door het totale aantal termen in dat document. (bijv. als het woord "kat" 3 keer voorkomt in een document met 100 woorden, is de TF van "kat" 3/100 = 0.03 = 3\%)
    Inverse Document Frequency (IDF) is een maatstaf voor hoe belangrijk een term is in een verzameling documenten.
    Het wordt berekend door het totale aantal documenten te delen door het aantal documenten waarin de term voorkomt, en vervolgens de logaritme van dat quotiënt te nemen. (bijv. als het woord "kat" voorkomt in 10 van de 1000 documenten, is de IDF van "kat" log(1000/10) = log(100) = 2)
    De combinatie van TF en IDF, oftewel $TF\times IDF$, wordt gebruikt om de relevantie van een term in een document te bepalen binnen een verzameling documenten.
    Een hoge $TF\times IDF$-waarde geeft aan dat een term vaak voorkomt in een document, maar zelden in andere documenten, wat suggereert dat de term belangrijk is voor dat specifieke document.


    \section{RDF (Resource Description Framework)}
    RDF is een standaardmodel voor het uitwisselen van gegevens op het web.
    Het is ontworpen om gegevens te beschrijven in een gestructureerde en machine-leesbare manier.
    RDF maakt gebruik van een grafenmodel om gegevens te representeren, waarbij gegevens bestaan uit een subject, predicaat en object.
    Dit maakt het mogelijk om complexe relaties tussen gegevens te modelleren en te analyseren.

    \begin{verbatim}
    subject:  http://example.org/person/Alice
    predicate: http://xmlns.com/foaf/0.1/knows
    object:   http://example.org/person/Bob
    \end{verbatim}

    In dit voorbeeld beschrijft de RDF-verklaring dat Alice Bob kent.
    RDF maakt gebruik van Uniform Resource Identifiers (URI's) om resources te identificeren, wat zorgt voor een unieke en consistente manier om gegevens te verwijzen.

    \textbf{FOAF} (Friend Of A Friend) is ontwikkeld om mensen en hun relaties (met andere mensen of objecten) te beschrijven op het web.

    Binnen het RDF heb je ok het RDF Schema (RDFS), dit is een verzameling van klassen en eigenschappen die worden gebruikt om RDF-gegevens te beschrijven.
    Bijvoorbeeld, je kunt een klasse "Persoon" definiëren en eigenschappen zoals "heeftNaam" en "heeftLeeftijd" om de attributen van een persoon te beschrijven.
    RDF en RDFS beschrijven alleen de structuur van de gegevens, maar niet de betekenis ervan.

    \subsection{linked data}
    Linked Data is een methode om gestructureerde gegevens op het web te publiceren en te verbinden.
    Het maakt gebruik van RDF om gegevens te beschrijven en URI's om resources te identificeren.
    Linked Data maakt het mogelijk om gegevens van verschillende bronnen te combineren en te integreren, waardoor een rijker en meer verbonden web van gegevens ontstaat.
    Het concept van Linked Data is gebaseerd op vier principes:
    \begin{itemize}
        \item Gebruik URI's om resources te identificeren.
        \item Gebruik HTTP-URI's zodat resources kunnen worden opgezocht op het web.
        \item Gebruik RDF om gegevens te beschrijven.
        \item Verbind je gegevens met andere gegevensbronnen om een web van gegevens te creëren.
    \end{itemize}

    Zo is het dus mogelijk om af te leiden dat een persoon een studeert met een x aantal medestudenten:

    \begin{multicols}{2}

        \begin{itemize}
            \item <http://example.org/person/MattTerSteege>
            \item rdf:type foaf:Person
            \item foaf:name "Matt ter Steege"
            \item foaf:studiesAt <http://dbpedia.org/resource/Universiteit\_Utrecht>
        \end{itemize}

        \begin{itemize}
            \item <http://dbpedia.org/resource/Universiteit\_Utrecht>
            \item dbp:student\_count "40000"
            \item dbp:location "Utrecht, Nederland"
        \end{itemize}

    \end{multicols}

    \subsection{SPARQL}
    SPARQL is een querytaal voor het opvragen en manipuleren van RDF-gegevens.
    Het stelt gebruikers in staat om complexe queries uit te voeren op RDF-datasets en specifieke informatie op te halen.
    Een query bestaat uit een prefix-declaratie, een select-verklaring en een waar-verklaring.
    Bijvoorbeeld, de volgende SPARQL-query haalt de namen op van alle personen die studeren aan de Universiteit Utrecht:

    \begin{verbatim}
    PREFIX foaf: <http://xmlns.com/foaf/0.1/>
    SELECT ?name
    WHERE {
        ?person foaf:studiesAt <http://dbpedia.org/resource/Universiteit_Utrecht> .
        ?person foaf:name ?name .
    }
    \end{verbatim}

    * De ``?name'' betekendt hetzelde als ``<http://xmlns.com/foaf/0.1/name>'' maar dan korter geschreven.


    \section{Webnavigatie}

    \subsection{Web usage mining}
    Dit gaat over het ontdekken van patronen in webdata, zoals gebruikersgedrag op websites.
    Het doel is om inzicht te krijgen in veel bezochte pagina's en websites of veel voorkomende paden van navigatie.
    Zo kan je begrijpen welke taken en behoeften gebruikers hebben, wat gebruiksonvriendelijke elementen zijn en hoe je de website kunt verbeteren (UI/UX of snelhied etc.).
    Het volgende zijn ook voorbeelden:

    \begin{itemize}
        \item Identificeren van advertentielocaties.
        \item Optimaliseren van menu-desing.
        \item Herkennen van bots en frauduleuze activiteiten.
        \item Personaliseren van content en aanbevelingen.
        \item Voorspellen van de volgende actie van een gebruiker
    \end{itemize}

    \subsection{gebruikersdata}
    \textbf{Gebruikersprofielen}: zijn gegevens die door de gebruiker zelf zijn verstrekt, zoals naam, leeftijd, geslacht, locatie en interesses.
    \textbf{Gebruiksdata}: omvat informatie over hoe gebruikers omgaan met een website, zoals bezochte pagina's, klikgedrag, tijd besteed op pagina's en navigatiepaden.

    Deze data kan je op verschillende manieren verzamelen, zoals:
    \begin{itemize}
        \item \textvf{Webserver}: Voornamelijk klikgedrag, bezochte pagina's en tijd op pagina.
        \item \textvf{Webclient}: Data van één gebruiker op verschillende sites, zoals muisbewegingen, scrollgedrag en interacties.
        \item \textvf{Proxyservers}: Data van meerdere gebruikers, zoals bezochte sites en algemene navigatiepatronen.
    \end{itemize}

    \subsection{Webserverdata}: Als een gebruiker een website bezoekt, registreert de webserver automatisch verschillende gegevens, zoals het IP-adres van de gebruiker, de tijd van het bezoek, de bezochte pagina's en de duur van het bezoek.
    Deze gegevens worden opgeslagen in logbestanden die later kunnen worden geanalyseerd om inzicht te krijgen in het gedrag van gebruikers op de website.

    Een voorbeeld van een webserverlogbestand:

    \begin{verbatim}
    •  213.6.31.68 - - [01/May/2004:22:38:32 +0200] "GET
        /forsale.html HTTP/1.1" 200 14956
        "http://www.fortepiano.nl/indexforsale.html" "Mozilla/4.0
        (compatible; MSIE 6.0; Windows NT 5.1)

    • 213.6.31.68 - - [01/May/2004:22:38:34 +0200] "GET
        /pictures/forsale/bertsche1835-small.jpg HTTP/1.1" 200 5753
        "http://www.fortepiano.nl/forsale.html" "Mozilla/4.0
        (compatible; MSIE 6.0; Windows NT 5.1)
    \end{verbatim}

    Zo'n logbestand bestaat uit alle requests aan een webserver/website.
    Als je hier data uit wilt halen, dan moet je deze eerst voorbewerken (cleanen).

    \begin{enumerate}
        \item \textbf{Data cleaning}: Verwijder onnodige gegevens, zoals requests voor afbeeldingen, scripts en stylesheets.
        \item \textbf{User identification}: Identificeer unieke gebruikers op basis van IP-adressen en user-agent strings.
        Je kunt dit doen door bijvoorbeeld cookies te gebruiken, maar accounts of headers kunnen ook helpen.
        \item \textbf{Session identification}: Groepeer requests van dezelfde gebruiker binnen een bepaalde tijdsperiode tot één sessie.
        Je kunt hiervoor een tijdslimiet instellen (bijv. 30 minuten van inactiviteit betekent het einde van een sessie).
        \item \textbf{Path completion}: Vul ontbrekende pagina's in die mogelijk zijn overgeslagen door caching of directe toegang.
        \item \textbf{Robot identification}: Identificeer en verwijder requests van webcrawlers en bots.
        Dit kan gedaan worden door user-agent strings te analyseren of door bekende IP-adressen van bots te blokkeren.
        Maar ook door het gedrag te analyseren (bijv. als een gebruiker in een paar seconden 100 pagina's bezoekt, is het waarschijnlijk een bot).
    \end{enumerate}

    \subsection{webclientdata}
    Webclientdata wordt verzameld via scripts die op de client-side (de browser van de gebruiker) worden uitgevoerd.
    Deze scripts kunnen informatie verzamelen over het gedrag van de gebruiker op de website, zoals muisbewegingen, scrollgedrag, klikgedrag en tijd besteed op pagina's.
    Deze gegevens worden vervolgens naar de server gestuurd voor analyse.
    Populaire tools voor het verzamelen van webclientdata zijn Google Analytics, Hotjar en Mixpanel.
    Dit is door de GDPR wet aardig in onbruik geraakt.

    \textbf{Conversion tracking}: Dit houdt bij hoeveel gebruikers een specifieke actie voltooien, zoals het invullen van een formulier of het doen van een aankoop.
    Dit werd vaak gedaan met een ``spy pixel'', een onzichtbaar beeld dat wordt geladen wanneer een gebruiker een bepaalde pagina bezoekt.
    Om te checken hoe goed emailcampagnes werken of advertenties.


    \section{Voorspellende modellen}

    \subsection*{Wat zijn voorspellende modellen}
    Voorspellende (of probabilistische) modellen proberen niet \textit{zeker} te weten wat een gebruiker gaat doen, maar schatten de kans dat een bepaalde handeling zal plaatsvinden. Alles draait om waarschijnlijkheden. Je kijkt naar eerder gedrag en zegt: \textit{op basis hiervan is dit de meest waarschijnlijke volgende stap}.

    Een handeling noemen we (a). De kans dat deze handeling voorkomt ligt altijd tussen 0 en 1:

    \[
    0 \leq P(a) \leq 1
    \]

    Deze kans heet de a-priori kans. Die staat los van context. Sommige handelingen gebeuren vaak (homepage bezoeken), andere zelden (voorwaardenpagina openen).

    \subsection*{Voorwaardelijke kansen}
    Zodra je context meeneemt, verandert het spel. Als handeling (b) vaak gevolgd wordt door handeling (a), dan wordt (a) waarschijnlijker zodra (b) is waargenomen.

    Dat schrijven we als:

    \[
    P(a \mid b)
    \]

    Dit lees je als: \textit{de kans op a, gegeven dat b heeft plaatsgevonden}.

    Concreet:

    \[
    P(a \mid b) = \frac{\text{aantal keren dat b gevolgd wordt door a}}{\text{aantal keren dat b voorkomt}}
    \]

    Dit is nog steeds simpel tellen, maar nu mét context.

    \subsection*{Theorema van Bayes}
    Bayes generaliseert dit idee. Niet één vorige handeling telt mee, maar een hele set bewijsstukken (E) (een keten van acties).

    De formule:

    \[
    P(a \mid E) = \frac{P(E \mid a) \cdot P(a)}{P(E)}
    \]

    Wat hier gebeurt:

    \begin{itemize}
        \item (P(a)): hoe waarschijnlijk was actie a sowieso al


        \item $(P(E \mid a))$: hoe goed past het waargenomen gedrag bij actie a


        \item (P(E)): normalisatie, zodat de kans geldig blijft


    \end{itemize}
    In praktijk: gebruikersgeschiedenis weegt mee, maar nooit zonder de basispopulariteit van een actie te corrigeren.

    \subsection*{Rankingmethoden op basis van a-priori kansen}
    Niet alle pagina’s zijn gelijk. Sommige pagina’s worden structureel vaker bezocht dan andere. Rankingmethoden proberen pagina’s te ordenen op basis van herbezoekkans.

    Typische observaties:

    \begin{itemize}
        \item Een klein aantal pagina’s trekt het merendeel van het verkeer


        \item Gebruikers keren vaak terug naar recent bezochte pagina’s


    \end{itemize}
    Dit leidt tot eenvoudige, maar verrassend effectieve methoden.

    \subsection*{Last Recently Used (LRU)}
    LRU kijkt alleen naar \textit{recentheid}.

    \[
    LRU(m_i, I_{m_i}, i_n) = \frac{1}{i_n - i_k + 1}
    \]

    Waar:

    \begin{itemize}
        \item $(i_n)$ de index is van het laatste paginabezoek


        \item $(i_k)$ de index is van het laatste bezoek aan pagina $(m_i)$


    \end{itemize}
    Hoe recenter het bezoek, hoe hoger de score.

    \subsection*{Most Frequently Used (MFU)}
    MFU kijkt alleen naar \textit{frequentie}.

    \[
    MFU(m_i, I_{m_i}, i_n) = \frac{|I_{m_i}|}{i_n}
    \]

    Pagina’s die vaak bezocht zijn in het verleden krijgen een hogere kans, ongeacht hoe lang geleden dat was.

    \subsection*{Polynomial Decay (PD)}
    Polynomial Decay combineert frequentie en recentheid.

    \[
    PD(m_i, I_{m_i}, i_n) = \sum_{j=1}^{|I_{m_i}|} \frac{1}{1 + (i_n - i_j)^\alpha}, \quad 0 < \alpha \leq 1
    \]

    Recente bezoeken tellen zwaarder dan oude. De parameter $(\alpha)$ is bepalend:

    \begin{itemize}
        \item hoge $(\alpha)$: snelle afname, focus op recentheid


        \item lage $(\alpha)$: langzamere afname, focus op frequentie


    \end{itemize}

    \subsection*{Markov-modellen}
    Markov-modellen veronderstellen dat de volgende actie afhangt van eerdere acties.

    Een eerste-orde Markov-model gaat ervan uit dat alleen de \textit{laatste} actie relevant is.

    \[
    P(s_n) = P(s_1) \prod_{t=2}^{n} P(s_t \mid s_{t-1})
    \]

    Dit model kan worden weergegeven als een transitiematrix:


    \begin{tabular}{c|cccc|c}
        From/To & A & B & C & D & Totaal \\ \hline
        A & & 3 & 5 & 8 & 16 \\
        B & 3 & & 7 & 4 & 14 \\
        C & 2 & 4 & & 6 & 12 \\
        D & 1 & 6 & 2 & & 9 \\
    \end{tabular}


    Elke cel geeft aan hoe vaak een overgang is waargenomen.

    \subsection*{Hogere-orde Markov-modellen}
    Bij hogere-orde modellen hangt de volgende actie af van de laatste (k) acties. Dit is realistischer, maar schaalt slecht. Daarom worden pagina’s of gebruikers vaak geclusterd om matrices hanteerbaar te houden.

    \subsection*{Associatieregels}
    Associatieregels kijken niet naar volgorde, maar naar \textit{samen voorkomen}.

    Een regel heeft de vorm:

    \[
    X \Rightarrow Y
    \]

    Waarbij (X) en (Y) verzamelingen van items zijn zonder overlap.

    \subsection*{Support en Confidence}
    Support:

    \[
    support(X \Rightarrow Y) = \frac{|{t_i \in D : X \cup Y \subset t_i}|}{|D|}
    \]

    Confidence:

    \[
    confidence(X \Rightarrow Y) = \frac{|{t_i \in D : X \cup Y \subset t_i}|}{|{t_i \in D : X \subset t_i}|}
    \]

    Support is vaak laag, confidence moet hoog zijn om de regel bruikbaar te maken.

    \subsection*{A-priori algoritme}
    Het A-priori algoritme reduceert de zoekruimte drastisch:

    \begin{itemize}
        \item Als een itemset niet frequent is, kan geen enkele superset frequent zijn


        \item Frequent-itemsets worden iteratief opgebouwd


    \end{itemize}
    Dit maakt het vinden van associatieregels praktisch uitvoerbaar.

    \subsection*{Praktische realiteit}
    Niet elk product of elke pagina volgt hetzelfde patroon.
    Wat werkt voor media en smaakgevoelige producten, faalt bij seizoensgebonden of functionele aankopen.
    Voorspellende modellen zijn krachtig, maar alleen zolang je accepteert dat gebruikersgedrag niet netjes, stabiel of symmetrisch is.

    \section{Kennis zoeken}

    \subsection{Interfaces ontwerpen}
    \textbf{Waarom ontwerpen gebruikers geen interfaces?}
    Nou, dat komt door een paar dingen, zoals:

    \begin{itemize}
        \item Gebrek aan technische kennis, het idee hebben ze misschien wel, maar niet de vaardigheden om het uit te voeren.
        \item Gebruikers zien vaak niet of er andere interfaces zijn die beter bij hun behoeften passen.
        Zo heb je in het begin van het gebruik van een interface hulp nodig met alles vinden, leren en begrijpen (dmv wizards, menu's etc.).
        Maar als je het eenmaal onder de knie hebt, dan wil je graag sneltoetsen en shortcuts gebruiken, omdat dat nou eenmaal sneller werkt.
        \item Gebruikers weten simpelweg niet of ze de interface fijn vinden totdat het af is.
    \end{itemize}

    \subsection{verschillende categorieën van informatie zoeken}

    \begin{itemize}
        \item \textbf{Serendipitous browsing}: Je bent niet echt op zoek, je kijkt gewoon rond en hoopt iets interessants te vinden.
        \item \textbf{Exploratory seeking}: Je hebt een vaag doel, maar je moet alleen nog meer informatie vinden om dat doel te bereiken.
        \item \textbf{Semi-directed browsing}: Je hebt een specifiek doel, maar je weet niet precies waar je moet zoeken.
        \item \textbf{Known-item searching}: Je weet precies wat je zoekt en waar je het kunt vinden.
        \item \textbf{Re-finding}: Je hebt eerder iets gevonden, maar je moet het opnieuw vinden.
    \end{itemize}

    \subsection{Information Foraging}
    De information foraging theorie is gebaseerd op het idee dat mensen die op zoek zijn naar informatie zich net zo gedragen als dieren op zoek naar eten.
    We hebben ingebouwde zoek- en jachtstrategieën die we automatisch toepassen.
    Deze strategieën zijn het resultaat van millennia aan evolutie.
    De theorie gaat ervan uit dat mensen (en dieren), binnen hun mogelijkheden, de beste strategie kiezen om met zo weinig mogelijk moeite (verbruikte energie) het beste resultaat krijgen (een volle maag, de benodigde kennis).

    \subsection{Modellen van information foraging}
    \textbf{Information patch model}: Dit model stelt dat informatie zich bevindt in ``patches'` of clusters, vergelijkbaar met voedselbronnen in de natuur.
    Gebruikers moeten beslissen wanneer ze een patch moeten verlaten en naar een nieuwe moeten gaan, gebaseerd op de hoeveelheid beschikbare informatie en de moeite die het kost om deze te verkrijgen.\\
    \textbf{Information scent model}: Dit model richt zich op de signalen of ``scent'' die gebruikers volgen om informatie te vinden.
    Deze signalen kunnen bestaan uit hyperlinks, zoekresultaten of andere aanwijzingen die gebruikers helpen te navigeren naar de gewenste informatie.\\
    \textbf{Information diet model}: Dit model vergelijkt informatieconsumptie met voedselinname.
    Het suggereert dat gebruikers een ``dieet'' van informatie kiezen op basis van hun behoeften, voorkeuren en beschikbare tijd.\\

    Information Foraging gaat er niet van uit dat we ons volledig rationeel en logisch gedragen.
    We maken fouten, omdat we incomplete informatie hebben.
    We wegen de benodigde inspanning af tegen de verwachte opbrengst.
    Dit kan leiden tot suboptimale keuzes, maar het is vaak goed genoeg in de praktijk.

    Stel je voor, je bent een roofvogel die op zoek is naar voedsel.
    \begin{itemize}
        \item Hoeveel prooi kun ik vinden in een bepaald gebied?
        \item Zijn de dieren makkelijk of moeilijk te vangen? En zit er genoeg vlees aan?
        \item Hoeveel energie kost het om te jagen in dit gebied?
    \end{itemize}

    \subsubsection{Information patches}
    Informatie is vaak verdeeld is clusters of ``patches''.
    Denk aan een bibliotheek met verschillende secties (geschiedenis, wetenschap, kunst, enzovoort).
    Elke sectie is een informatiepatch met gerelateerde informatie.
    Gebruikers moeten beslissen wanneer ze een patch moeten verlaten en naar een nieuwe moeten gaan.
    Dit hangt af van de hoeveelheid beschikbare informatie en de moeite die het kost om deze te verkrijgen.

    Dit patch-model heeft een wiskundige formule centraal staan:
    \[
        R = \frac{G}{T_B + T_W}
    \]
    Waarbij:
    \begin{itemize}
        \item \( R \) is de opbrengst (reward rate)
        \item \( G \) is de hoeveelheid verkregen informatie (gain)
        \item \( T_B \) is de tijd besteed aan het vinden van een patch
        \item \( T_W \) is de tijd besteed aan het verwerken van informatie binnen een patch
    \end{itemize}
    Het doel is om \( R \) te maximaliseren door een optimale balans te vinden tussen \( G \), \( T_B \) en \( T_W \).

    Deze winstmaximalisatie kan je dus op 2(of 3) manieren bereiken:
    \begin{itemize}
        \item De tijd tussen de bossen verkleinen (sneller nieuwe patches vinden)
        Aks je dit doet dan gaat de winstverwachting omhoog.
        \item De tijd in de bossen verkleinen (sneller informatie verwerken)
        Als je dit doet, dan kan je meer patches bezoeken in dezelfde tijd, wat de totale informatieopbrengst verhoogt.
        De optimale ``within-patch'' tijd gaat hierdoor ook omlaag, want stel 75\% van de informatie is optimaal, dan ben je daar sneller als je sneller door de patch heen gaat.

        \item De hoeveelheid informatie per patch verhogen (betere kwaliteit informatie, maar kan je van tevoren niet weten)
        Als je dit doet, dan verhoog je de totale informatieopbrengst per patch, wat de winstverwachting verhoogt.
    \end{itemize}


    \subsubsection{Informatiezoekers}
    Informatiezoekers zijn als jagers die op zoek zijn naar informatie.
    Denk aan studenten, onderzoekers, kantoorpersoneel, enzovoort.
    Deze hebben informatie nodig om hun taken uit te voeren, beslissingen te nemen of problemen op te lossen.
    \begin{itemize}
        \item De informatie is aanwezig in boeken, emails, chatlogs, websites, databases, enzovoort.
        \item Sommige zijn uitgebreid en complex, andere zijn simpel en rechttoe rechtaan.
        \item Online bronnen zijn sneller toegankelijk, maar een boek lenen kost tijd.
    \end{itemize}



\end{document}